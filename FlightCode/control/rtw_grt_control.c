/*! \file rtw_grt_control.c
 *	\brief Wrapper for Real Time Workshop generated code, using grt.tlc
 *
 *	\details This file is a wrapper for Matworks Real Time Workshop generated code, using the grt.tcl (generic
 *	real time target). This file is included in the auto generated code.
 *
 *	\ingroup control_fcns
 *
 *	\author University of Minnesota
 *	\author Aerospace Engineering and Mechanics
 *	\copyright Copyright 2011 Regents of the University of Minnesota. All rights reserved.
 *
 * $Id: rtw_grt_control.c 810 2012-04-25 16:46:43Z murch $
 */
 
#include "../globaldefs.h"
#include "control_interface.h"

// Declare function prototypes
void MdlUpdate(int_T tid);
void MdlOutputs(int_T tid);
void MdlInitialize(void);


void get_control(double time, struct sensordata *sensorData_ptr, struct nav *navData_ptr, struct control *controlData_ptr, struct mission *missionData_ptr){

	// Populate the reference commands and feedback inputs for the Simulink diagram.
	// See ../../Documentation/UAV_controllaw_ICD.xlsx for details.

	// Guidance Commands
	rtU.ref_cmds[0] = controlData_ptr->phi_cmd;
	rtU.ref_cmds[1] = controlData_ptr->theta_cmd;
	rtU.ref_cmds[2]= controlData_ptr->psi_cmd;
	rtU.ref_cmds[3] = controlData_ptr->p_cmd;
	rtU.ref_cmds[4] = controlData_ptr->q_cmd;
	rtU.ref_cmds[5] = controlData_ptr->r_cmd;
	rtU.ref_cmds[6] = controlData_ptr->ias_cmd;
	rtU.ref_cmds[7] = controlData_ptr->h_cmd;
	rtU.ref_cmds[8] = controlData_ptr->gndtrk_cmd;
	rtU.ref_cmds[9] = controlData_ptr->aoa_cmd;
	rtU.ref_cmds[10] = controlData_ptr->aos_cmd;
	rtU.ref_cmds[11] = controlData_ptr->gamma_cmd;

	// IMU Data
	rtU.feedback[3] = sensorData_ptr->imuData_ptr->p;
	rtU.feedback[4] = sensorData_ptr->imuData_ptr->q;
	rtU.feedback[5] = sensorData_ptr->imuData_ptr->r;
	rtU.feedback[6] = sensorData_ptr->imuData_ptr->ax;
	rtU.feedback[7] = sensorData_ptr->imuData_ptr->ay;
	rtU.feedback[8] = sensorData_ptr->imuData_ptr->az;
	
	// Air Data
	rtU.feedback[9] = sensorData_ptr->adData_ptr->h;
	rtU.feedback[10] = sensorData_ptr->adData_ptr->ias;
	rtU.feedback[11] = sensorData_ptr->adData_ptr->aoa;
	rtU.feedback[12] = sensorData_ptr->adData_ptr->aos;
	
	// Nav Data
	rtU.feedback[13] = navData_ptr->lat;
	rtU.feedback[14] = navData_ptr->lon;
	rtU.feedback[15] = navData_ptr->alt;
	rtU.feedback[16] = navData_ptr->ve;
	rtU.feedback[17] = navData_ptr->vn;
	rtU.feedback[18] = navData_ptr->vd;	
	rtU.feedback[0] = navData_ptr->phi;
	rtU.feedback[1] = navData_ptr->the;
	rtU.feedback[2] = navData_ptr->psi;

	// Call the autogenerated code. 
	MdlUpdate(0); // First update the internal states
	MdlOutputs(0); // Then compute the outputs
	
	// Assign Simulink diagram outputs to get_control data structure
	controlData_ptr->dthr = rtY.control_cmd[0]; // throttle
	controlData_ptr->de   = rtY.control_cmd[1];	// elevator 
	controlData_ptr->dr   = rtY.control_cmd[2];	// rudder
	controlData_ptr->da_l = rtY.control_cmd[3];	// left aileron
	controlData_ptr->da_r = rtY.control_cmd[4];	// right aileron
	controlData_ptr->df_l = rtY.control_cmd[5]; // left flap
	controlData_ptr->df_r = rtY.control_cmd[6]; // right flap
}

void reset_control(struct control *controlData_ptr){
	// Reset internal states to initial condition
	MdlInitialize();
	
	controlData_ptr->dthr = 0; // throttle
	controlData_ptr->de   = 0; // elevator
	controlData_ptr->dr   = 0; // rudder
	controlData_ptr->da_l = 0; // left aileron
	controlData_ptr->da_r = 0; // right aileron
	controlData_ptr->df_l = 0; // left flap
	controlData_ptr->df_r = 0; // right flap
}
